% --- Inicjalizacja dokumentu --------------------------------------------------

\documentclass[12pt,a4paper,titlepage,twoside]{mwart}
\usepackage{latexsym}
\usepackage{polski}
\usepackage{array}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{a4wide}
\usepackage{fancyhdr}
\usepackage{tabularx}
\usepackage{enumitem}
\usepackage{listings}
\usepackage{graphicx}
\pagestyle{fancy}
\lstset{language=[ANSI]C,frame=single,captionpos=b,xleftmargin=20mm,xrightmargin=20mm}

% --- Zdefiniowanie autora i tytułu --------------------------------------------
\author{Krystian Bacławski}
\title{Praca magisterska}

\frenchspacing

\begin{document}

\maketitle
\cleardoublepage

\tableofcontents
\cleardoublepage

% ------------------------------------------------------------------------------

\setlength{\parindent}{0pt}
\setlength{\parskip}{1.2ex plus 0.5ex minus 0.2ex}

\section{Motywacja}

Algorytmy zarządzania stertą towarzyszą informatyce od samych jej początków.
Allokatorów sterty zaczęto używać, kiedy pojawiły się pierwsze dynamiczne
struktury danych, takie jak listy i drzewa, a sama pamięć była na tyle duża, by
zmieścić w niej większe problemy. Mimo, że minęło 50 lat od pojawienia się
pierwszych algorytmów z tej klasy, dziedzina ta nadal nie jest wyczerpująco
zbadana od strony praktycznej. Przyczyny są dwojakiej natury. Po pierwsze --
duży wpływ na działanie allokatora ma specyfika sprzętu -- w szczególności
wielowarstwowy model pamięci i wieloprocesorowość dzisiejszych komputerów. Po
drugie -- programy allokujące pamięć z reguły korzystają z allokatora w pewien
określony sposób, zdradzając przy tym ściśle określone wzorce.

Ewolucja sprzętu spowodowała, że dobry algorytm zarządzania stertą 
musi charakteryzować się niską fragmentacją, krótkim zamortyzowanym czasem
przypadającym na jedną operację i wykorzystaniem lokalności bloków.
Umiejętna implementacja korzystająca ze specyfiki pamięci ma również wpływ
na prędkość algorytmów korzystających z allokatora.

System Linux posiada bardzo dobre algorytmy zarządzania stertą, zarówno te
działające w przestrzeni użytkownika (biblioteka glibc i glib) jak i w
przestrzeni jądra. Niestety nie są to ani algorytmy uniwersalne, ani łatwo
modyfikowalne na potrzeby programisty. Celem tej pracy jest zaimplementowanie
allokatora pamięci działającego w pamięci dzielonej procesu. Specyfika tego
problemu zostanie przestawiona w dziale \textbf{Implementacja}.

% --=[ Wstęp teoretyczny ]=-----------------------------------------------------

\section{Wstęp teoretyczny}

Zarządcy pamięci są algorytmami tak powszechnymi, że niemal nie zauważa się ich
istnienia. Programiści traktują wywołania funkcji realizujących przydzielanie i
zwalnianie obszarów za czarne skrzynki -- nie wiedząc, że pod spodem tkwią
często zaawansowane algorytmy, a czasem również dość nieefektywne w pewnych
przypadkach. Celem tego rodziału jest przedstawienie podstawowych koncepcji
związanych z dostępem do pamięci i jej zarządzaniem.

\subsection{Intuicyjna definicja problemu}

Zarządca sterty to algorytm on-line, który operuje na pewnym obszarze pamięci
w przestrzeni adresowej programu. Obiektami, którymi się zajmuje są bloki
pamięci. Manadżer musi pamiętać, które bloki są przydzielane programowi, a
które są nieużywane.

\parbox{\textwidth}{
Blok jest spójnym obszarem pamięci o następujących właściwościach:
\par\vspace{2mm}
\begin{tabularx}{\textwidth}{@{\hspace{4ex}}lX@{}}
	\textbf{położenie}	& adres obszaru pamięci, w którym się zaczyna. \\
	\textbf{wielkość}	& mierzona (zazwyczaj) w bajtach. \\
	\textbf{narodziny}	& kwant czasu, w którym zarządca oddaje blok na użytek programu. \\
	\textbf{śmierć}		& kwant czasu, w którym program oddaje blok na użytek zarządcy. \\
	\textbf{właściciel}	& proces lub wątek, któremu ten blok został przypisany. \\
\end{tabularx}
}

\parbox{\textwidth}{
Zarządca odpowiada na dwa typy żądań programu:
\par\vspace{2mm}
\begin{tabularx}{\textwidth}{@{\hspace{4ex}}lX@{}}
	\textbf{malloc} & które zwraca adres bloku pamięci o żądanym
	rozmiarze lub informuje, że żądanie nie mogło zostać spełnione. \\

	\textbf{free} & które oddaje obszar zajmowany przez blok pamięci o
	podanym adresie do ponownego użycia przez algorytm zarządcy. \\
\end{tabularx}
}

\subsubsection{Fragmentacja}

Warto wspomnieć o tym, że blok z reguły jest większy niżby wynikało to z
wartości przekazywanej do funkcji \textbf{malloc}.  Może to wynikać np. z
pewnych założeń co do architektury sprzętu -- często jednostka alokacji jest
równa rozmiarowi największej elementarnej danej, którą może przetwarzać
procesor -- jak i tego, że algorytm może chcieć składować gdzieś dane niezbędne
do przetwarzania bloków.

Większość znanych alokatorów pamięci dla systemów operacyjnych przeznaczonych
dla procesorów z rodziny Intel IA-32 za jednostkę alokacji przyjmuje 8 bajtów,
co odpowiada rozmiarowi najdłuższej danej całkowitej oznaczanej w języku C jako
'long long int'.

Zarządca jest właściwie wyłącznie odpowiedzialny za wyznaczanie położenia
obszaru pamięci, w którym będzie się znajdował blok i wszystkie niezbędne dane
z nim związane. Algorytm wyznacza położenie danego bloku tylko raz -- tj. nie
może go przemieszczać, ani zmieniać danych w nim zawartych (poza tymi, które są
przeznaczone na struktury danych zarządcy), jeśli blok został już przydzielony.



Ogólna definicja problemu zarządzania stertą jako algorytmu on-line.

Przyjrzyjmy się trzem podstawowym wariantom problemu zarządzania pamięcią.

\subsubsection{Klasyczna wersja problemu}

Blok pamięci długości $n$-słów. Operacje: malloc, free.

\subsubsection{Zarządzenie stronami pamięci}

Większość ówczesnych komputerów ma pewne mechanizmy zarządzania pamięcią
zaimplementowane sprzętowo. Mechanizmy te tworzono z myślą o systemach
operacyjnych i użyciu ich do usprawnienia działania procesów.

Jądro systemu uniksowego nie udostępnia procesom przestrzeni użytkownika
mechanizmu zarządzania pamięcią dla bloków różnej długości. Implementacja
popularnych funkcji malloc/free jest wczytywana z biblioteki libc. Proces
użytkownika, może od systemu zarządać jedynie pewnej ilość tzw. ramek pamięci
-- bloków z reguły wielkości 4KB. Z punktu widzenia procesora taki blok to
najmniejsza jednostka pamięci, której właściwości jest w stanie kontrolować.
Jądro systemu zarządza pamięcią fizyczną tworząc przestrzeń adresową na
potrzeby procesu. Systemy partnerskie (ang. Buddy Systems) są podstawowym
algorytmem zarządzania pamięcią fizyczną w systemie Linux.

\subsubsection{Zarządzenie pamięcią dla bloków jednakowej wielkości}

Wiele dynamicznych struktur danych drzewa charakteryzuje się stałą wielkością
rekordu -- w przypadku drzewa jest to węzeł. Mając na względzie takie
ograniczenia problemu, można łatwo zapanować nad problemem lokalności w algorytmach

\subsubsection{Zarządzenie pamięcią dla bloków różnej wielkości}

Najbardziej ogólny wariant algorytmu. Na potrzeby programistów jest on
osiągalny przez wywołania malloc/free z biblioteki standardowej języka C.

% --=[ Podstawy architektury pamięci ]=-----------------------------------------

\section{Podstawy architektury pamięci}

Przed przystąpieniem do realizacji jakiegokolwiek algorytmu zarządzania stertą
należy dokładnie przeanalizować strukturę pamięci. Struktura pamięci to pojęcie
bardzo ogólne określające kilka aspektów -- począwszy od sprzętowych po
wywołania systemowe umożliwiające pobieranie oraz zwalnianie obiektów. Dopiero
mając na uwadze wszystkie zagadnienia związane z organizacją pamięci można
planować efektywny pod względem szybkości jak i zajmowanego miejsca menadżer
pamięci.

W tym rozdziale zostaną omówione podstawy i pojęcia związane z:
\begin{itemize}
\item organizacją sprzętową pamięci dla architektury sprzętowej Intel IA-32,
\item przestrzeni adresowej programu i jej obłożenia w systemie Linux,
\item interfejsem rezerwacji i zwalnianiem stron w systemach uniksowych,
\item zagadnieniami wydajności pamięci w systemach jedno- i wieloprocesorowych,
\item metodami synchronizacji dla programów wielowątkowych.
\end{itemize}

\subsection{Stronicowanie}

Pamięć fizyczna jest to rodzaj pamięci widziany bezpośrednio przez procesor.
Podstawową jednostką zarządzania tym rodzajem pamięci jest strona, będąca
obszarem o następujących własnościach:

\begin{itemize}
\item pewnej z góry ustalonej wielkości (w przypadku procesorów Intel
IA-32 jest to 4KiB lub 4MiB),
\item adres jej początku jest podzielny przez długość strony,
\item posiada zestaw uprawnień (do odczytu, do zapisu, itd.)
\end{itemize}

Nad pamięcią fizyczną system operacyjny, korzystając z jednostki zarządzania
pamięcią procesora, buduje warstwę zwaną pamięcią logiczną. Zadanie to jest
realizowane przez mechanizm translacji adresów -- często określany także
mechanizmem stronicowania. Do translacji adresów procesor wykorzystuje opis
pamięci logicznej składający się na wielopoziomowe tablice deskryptorów stron.

\begin{figure}
\centering
\includegraphics[width=0.75\textwidth]{stronicowanie}
\caption{Schemat translacji adresu dla architektury Intel IA-32}
\end{figure}

Procesor posiada rejestr PDBR, w którym składuje wskaźnik o adresie wyrównanym
do granicy 4096 bajtów, do katalogu stron. Każda pozycja w katalogu stron to 32
bitowe słowo. Zawiera ono 20 starszych bitów określających fizyczny adres
początku tablicy stron i 12 młodszych bitów na dodatkowe dane. Analogicznie
jest z deskryptorem strony, przy starsze 20 bitów podaje fizyczny adres
początku strony.

Kiedy program odwołuje się do pamięci logicznej procesor wykonuje następujące kroki:
\begin{enumerate}
\item rozbija adres na 3 części: 10-bitowy indeks w katalogu stron (PDE), 10-bitowy
indeks w tablicy stron (PTE) i 12 bitowy indeks wewnątrz strony (PO),
\item wyszukuje deskryptor katalogu zestawiając górne 20 bitów rejestru PDBR z
indeksem PDE -- wyznaczając adres fizyczny początku katalogu stron,
\item wyszukuje deskryptor strony zestawiając górne 20 bitów wyznaczające
początek tablicy stron z indeksem PTE -- adres fizyczny początku strony,
\item zestawia górne 20 bitów adresu fizycznego strony z indeksem PO i
realizuje operację odczytu lub zapisu danych.
\end{enumerate}

Przy pomocy młodszych 12 bitów w deskryptorze strony realizuje się w systemach
różne mechanizmy. Najbardziej znanymi mechanizmami są:
\begin{itemize}
\item \textit{ochrona pamięci} -- deskryptory stron przechowują bity uprawnień do
czytania, pisania, wykonywania zawartości -- procesor sprawdza te bity w
trakcie translacji adresu i w przypadku błędu dostępu generuje błąd
stronicowania (ang. \textit{Page Fault}),
\item \textit{pamięć wirtualna} -- dodatkowe bity w deskryptorze oznaczają czy
strona znajduje się w pamięci fizycznej -- system operacyjny może dane strony
przemieszczać do pamięci zewnętrznej i na odwrót, obsługując odpowiednio błąd
stronicowania,
\item \textit{mapowanie pamięci} -- mechanizm analogiczny do pamięci wirtualnej
może służyć do mapowania plików na strony, dzięki temu programista może mieć
swobodny dostęp do pliku,
\item \textit{pamięć dzielona} -- system operacyjny umieszcza w pamięci logicznej kilku
procesów te same strony pamięci fizycznej.
\end{itemize}

Zasadniczo dwóch terminów: \textit{pamięć logiczna} i \textit{pamięć wirtualna}
mówiąc o mechaniźmie stronicowania często się nie rozróżnia i będę ich używać
zamiennie.

Nie sposób też pominąć istotną przewagę stronicowania nad innymi metodami
sprzętowego zarządzania pamięcią. Mechanizm ten umożliwia systemowi
operacyjnemu organizowanie rozrzuconych w pamięci fizycznej stron w jeden
spójny obszar w pamięci logicznej.

\subsection{Pamięć podręczna}

W tematyce związanej z architekturami systemów komputerowych często pojawia się
termin \textit{piramidy pamięci}. Porusza on zależność ilości pamięci od jej
wydajności. I tak najszybsze są w podanej kolejności: rejestry procesora,
pamięć cache, pamięć RAM, pamięć zewnętrzna (np.: twarde dyski). Niestety w
wyżej wymienionej kolejności rośnie również ilość danych, które te źródła
pamięci mogą przechowywać.

Pamięć podręczna (ang. \textit{cache}) jest kilkukrotnie szybsza od procesora.
Przechowuje najczęściej używane obszary, zakładając, że program przetwarzając
dane wykazuje pewną lokalność dostępów do poszczególnych komórek.

Pamięć podręczna przechowuje fragmenty pamięci RAM zwane liniami, którym
przyporządkowane są dodatkowe informacje niezbędne do funkcjonowania pewnych
szczególnych operacji dostępu. Kontroler szyny sprowadza i wydala z pamięci
podręcznej całe linie.

Podstawowymi właściwościami pamięci podręcznej są:
\begin{itemize}
\item szybkość -- ile cykli trzeba czekać na sprowadzenie danych jednostki
obliczeniowej procesora,
\item architektura -- bezpośrednio mapowana, wielodrożna, w pełni asocjacyjna,
\item ilość -- im szybsza pamięć podręczna tym jej mniej. 
\end{itemize}

Pamięć cache jest dla programisty do pewnego stopnia przezroczysta. Nie jest to
obszar bezpośrednio dostępny, a raczej bufor dla danych z pamięci RAM. Stosując
odpowiednie instrukcje można wymusić na kontrolerze szyny by sprowadził do
pamięci podręcznej linie o określonych adresach, bądź też wymusił wydalenie do
pamięci pewnych linii. Metody te w języku angielski noszą nazwę
\textit{prefetching} i \textit{cache invalidation}.

Zjawiskiem niepożądanym z punktu widzenia wydajności są sytuacje, kiedy
procesor próbuje korzystać z danych, które nie są w żadnej linii pamięci
podręcznej -- w języku angielskim nazywa się je \textit{cache miss}. W takim
przypadku procesor zamraża wykonywanie instrukcji do momentu kiedy dane będą
dostępne -- może się to wiązać z koniecznością wymiany pewnej linii tzn.
zapisania jej wartości do pamięci RAM, a następnie sprowadzenia w to miejsce
innego obszaru. Pesymistyczny wariant to wiele cykli mocy obliczeniowej
procesora zmarnowanych na oczekiwanie.

Powrócmy na chwilę do stronicowania. Jeśli dobrze się przypatrzeć mechanizmowi
to widać, że jest on kosztowny w sensie ilości operacji na pamięci. Każdy zapis
czy odczyt wymusza na procesorze dodatkowe dwie operacje dostępu do pamięci
celem obliczenia adresu fizycznego. Strony przechowujące katalogi i tablice
deskryptorów mogą być buforowane i z reguły umożliwia się ich składowanie w
pamięci podręcznej. Sytuacja, w której każdy odczyt pamięci przechowującej
deskryptory generuje \textit{cache miss} powoduje jeszcze większy spadek
wydajności. Dlatego jednostka zarządzania pamięcią posiada własną pamięć
podręczną nazywaną \textit{Table Lookaside Buffer}. Przechowuje ona pewną ilość
(z reguły kilkaset) deskryptorów stron umożliwiających natychmiastowe
obliczenie adresu fizycznego. Sytuacja, w której TLB nie przechowuje informacji
o stronie, do której odwołanie jest potrzebne, by dostarczyć dane dla
instrukcji, nazywa się \textit{TLB miss}.

\subsection{Przestrzeń adresowa w Linuksie}

Przestrzeń adresowa procesu to wszystkie komórki pamięci, które można
zaadresować w jednej chwili, ale nie koniecznie mieć do nich dostęp (w takim
przypadku wystąpi przerwanie naruszenia ochrony pamięci). W systemach
32-bitowych proces dysponuje przestrzenią adresową 4GB. Oznacza to nie ilość
pamięci fizycznej jaka maksymalnie może być dostępna dla procesu, a wielkość
danych, do których procesor może mieć dostęp w sposób bezpośredni, adresując
komórki pamięci. To rozróżnienie jest istotne, gdyż mechanizm stronicowania
jest bardzo elastyczny i umożliwia odwzorowanie przestrzeni adresowej na pamięć
zewnętrzną, pliki, pamięć urządzeń wejścia-wyjścia, itd.

Najnowsze systemy komputerowe mimo ograniczenia na przestrzeń adresową potrafią
umożliwić procesowi dostęp do większej ilości pamięci fizycznej niż wynosi
wielkość przestrzeni adresowej. Oczywiście mechanizm ten nie jest przezroczysty
dla programisty i wymusza używanie techniki zwanej przesuwającym się oknem
(ang. \textit{sliding window}) lub przełączaniem banków (ang. \textit bank
switching) -- kawałkiem przestrzeni adresowej, w którym widać fragment jakiejś
większej pamięci.

W systemach uniksowych oczywiście nie cała przestrzeń adresowa jest dostępna
dla procesu, jej część zajmuje jądro systemu. W tym fragmencie przestrzeni
jądro udostępnia swoje publiczne struktury, może mapować bufory, dane otrzymane
od urządzeń wejścia-wyjścia, itd.

\begin{figure}
\centering
\includegraphics[height=0.5\textwidth]{linux-layout}
\caption{Obłożenie przestrzeni adresowej procesu w systemie Linux}
\end{figure}

Na przestrzeń adresową procesu użytkownika w systemie Linux składają się
następujące obszary:

\begin{center}
\begin{tabular}{|ccc|p{0.5\linewidth}|}
\hline
\textsc{początek} & & \textsc{koniec} & \textsc{znaczenie} \\
\hline
\hline
\texttt{0x00000000} & -- & \texttt{0x07ffffff} & Obszar wyłapywania złych wskaźników -- dostęp zawsze zabroniony.\\
\hline
\texttt{0x08000000} & -- & \texttt{0x08xxxxxx} & Tu wczytywana jest sekcja \texttt{text} pliku ELF. Miejsce na kod i zainicjalizowane dane.\\
\hline
\texttt{0x08xxxxxx} & -- & \texttt{?}          & Obszar sterty. Może zmieniać rozmiar przy pomocy procedury brk.\\
\hline
\texttt{?}          & -- & \texttt{0xBFxxxxxx} & Obszar dla wywołania systemowego mmap. Tu będą mapowane pliki i inne obiekty.\\
\hline
\texttt{0xBFxxxxxx} & -- & \texttt{0xBFFFFFFF} & Stos programu.\\
\hline
\texttt{0xC0000000} & -- & \texttt{0xFFFFFFFF} & Przestrzeń na użytek jądra systemu -- do komunikacji z procesem.\\
\hline
\end{tabular}
\end{center}

\subsection{Metody rezerwacji stron w Linuksie}

Jądro linuksa nie udostępnia programom wywołań systemowych pełniących rolę
funkcji \texttt{malloc} i \texttt{free}. Zarządzanie ma o wiele bardziej
niskopoziomową postać. Linux umożliwia wyłącznie pobieranie i zwracanie pewnej
ilości stron poprzez umieszczanie ich w przestrzeni adresowej w obszarach do
tego zarezerwowanych. Menadżer pamięci musi być zatem zaimplementowany przez
pewną bibliotekę wgrywaną przez program w czasie startu.

\subsubsection{Wywołanie systemowe \texttt{brk}}

Pierwszym i historycznie najstarszym wywołaniem jądra do przydzielania pamięci
procesowi jest procedura \texttt{brk} i nakładka \texttt{sbrk}.

\vspace{4ex}

\begin{lstlisting}[caption={Prototypy procedur \texttt{brk} i \texttt{sbrk}.}]
int   brk(void *end_data_segment);
void *sbrk(intptr_t increment);
\end{lstlisting}

Procedura \texttt{brk} zmienia położenie wierzchołka sterty na zadany adres, o
ile ma on sens -- w przypadku sukcesu zwraca $0$, w przeciwnym razie zwraca $-1$.

Procedura \texttt{sbrk} przesuwa położenie wierzchołka sterty o zadaną ilość
bajtów przy czym wielkość ta może być ujemna. Zwraca nowy adres wierzchołka
sterty lub adres o wartości $-1$ w przypadku błędu.

Obie funkcje są dostępne w większości systemów uniksowych. Zostały jednak
usunięte ze standardu POSIX.1 i nie należy ich używać, jeśli kod ma być
przenośny między różnymi platformami. Innymi słowy tą metodę pozyskiwania
pamięci uważa się z przestarzałą i nie zaleca jej używania.

Wywołanie \texttt{brk} ma też oczywistą wadę, powodującą nieefektywne
wykorzystanie pamięci. Przypuścmy, że program wykonuje ciąg operacji:

\begin{enumerate}
\item zarezerwuj obszar $A$ o rozmiarze $n$,
\item zarezerwuj obszar $B$ o rozmiarze $m$ o wiele mniejszym niż $n$,
\item zwolnij obszar $A$,
\item zarezerwuj obszar $C$ o rozmiarze $n + m$.
\end{enumerate}

Widać, że każda rezerwacja obszaru będzie musiała przesunąć wierzchołek sterty.
Strony związane z obszarem $A$ nie mogą być zwrócone do systemu i ponownie
wykorzystanie do utworzenia obszaru $C$. Używanie tego mechanizmu do rezerwacji
dużych bloków jest nieefektywne i może powodować powstawanie nieużytków.

\subsubsection{Wywołanie systemowe \texttt{mmap}}

Historycznie nowszą, a jednocześnie zalecaną, metodą rezerwacji i zwalniania
spójnego obszaru stron pamięci stanowią wywołania \texttt{mmap} i
\texttt{munmap}. Zaletą tej metody pobierania pamięci z systemu operacyjnego
jest możliwość skonstruowania lepszej metody radzenia sobie z nieużytkami.
Zmapowany spójny obszar pamięci może być odmapowany fragmentarycznie. Jeśli
tylko pojawi się wystarczająco długi niewykorzystywany obszar rozpoczynający
się w adresie podzielnym przez rozmiar strony, program może go zwrócić do
systemu. 

Poniżej zostaną przedstawione i wyjaśnione parametry procedur dla przypadku
przydziału i zwalniania pamięci wirtualnej.

\vspace{4ex}
\begin{lstlisting}[caption={Prototypy procedur \texttt{mmap} i \texttt{munmap}.}]
void *mmap(void *start, size_t length, int prot,
           int flags, int fd, off_t offset);
int munmap(void *start, size_t length);
\end{lstlisting}

Argumenty procedury \texttt{mmap} posiadają następujące znaczenie w przypadku
żądania o przydział stron procesowi:
\begin{center}
\begin{tabular}{|l|p{0.75\linewidth}|}
\hline
\textsc{argument} & \textsc{znaczenie} \\
\hline
\hline
\verb+start+  & Adres, pod który powinny być zmapowane nowe strony. Jeśli równy
\texttt{NULL}, jądro samo wybierze odpowiednie miejsce w przestrzeni adresowej.
W przeciwnym wypadku będzie starało się wykorzystać ten argument jako początek
mapowania. Zaleca się ustawienie na \texttt{NULL}.\\
\hline
\verb+length+ & Rozmiar bloku pamięci -- musi być podzielny przez długość strony. \\
\hline
\verb+prot+   & Uprawnienia określające dostęp do stron. Jeśli proces chce
czytać i zapisywać do tego obszaru, argument musi mieć wartość
\verb+PROT_READ|PROT_WRITE+. \\
\hline
\verb+flags+  & Flaga \verb+MAP_ANONYMOUS+ powoduje zmapowanie pamięci
wirtualnej zamiast pliku. Zawartość pamięci będzie wyzerowana. \\
\hline
\verb+fd+     & Uchwyt pliku -- obowiązuje jedynie w przypadku mapowania pliku.
Ustawić na $-1$ dla zgodności z innymi systemami. \\
\hline
\verb+offset+ & Offset względem początku pliku -- jego wartość jest ignorowana. \\
\hline
\end{tabular}
\end{center}

W zależności od wartości \texttt{flags} wywołanie \texttt{mmap} może
przydzielać strony o różnych właściwościach. Objawiają się one w momencie
wywołania procedury systemowej \texttt{fork}, która tworzy potomków procesu.

\begin{center}
\begin{tabular}{|l|p{0.75\linewidth}|}
\hline
\textsc{flaga} & \textsc{znaczenie} \\
\hline
\verb+MAP_PRIVATE+ & Mapowanie prywatne. Proces posiada zmapowane strony na
własność. Wykorzystywany jest mechanizm \texttt{copy-on-write}. Jeśli
którykolwiek z potomków lub rodzic będzie chciał zmodyfikować stronę, to
dostanie jej prywatną kopię na własny użytek. \\
\hline
\verb+MAP_SHARED+  & Mapowanie dzielone. Proces dzieli zmapowany obszar pamięci
między wszystkie procesy potomne stworzone. Wszystkie procesy widzą ten sam
obszar pamięci wirtualnej i mogą się przez ten fragment pamięci komunikować. \\
\hline
\end{tabular}
\end{center}

Poniżej zamieszczono listing prostego programu pobierający stronę pamięci z
systemu operacyjnego na własny użytek.

\vspace{2ex}
\begin{lstlisting}[caption={Przykład pobrania i zwolnienia jednej strony.},xleftmargin=3ex,xrightmargin=3ex]
void *area = mmap(NULL, getpagesize(), PROT_READ|PROT_WRITE,
                  MAP_ANONYMOUS|MAP_PRIVATE, -1, 0);

if (area != NULL)
    munmap(area, getpagesize());
\end{lstlisting}

Ważną przewagą wywołania systemowego \texttt{mmap}, w stosunku do \texttt{brk},
jest to, że korzystanie z tej metody pobierania pamięci nie powoduje konfliktów z
menadżerem pamięci znajdującym się w bibliotece \texttt{libc}. Dzięki temu
można w obrębie jednej przestrzeni adresowej korzystać z wielu niezależnych
algorytmów rezerwacji bloków.

\subsection{Fałszywe współdzielenie}

Mikroprocesor wielordzeniowy nie jest już dziś niczym egzotycznym. Kiedyś były
składnikami wyłącznie maszyn pełniących rolę serwerów bądź stacji roboczych do
obliczeń naukowych. Większość architektur wieloprocesorowych lub
wielordzeniowych zakłada dostęp do pamięci systemowej, która jest dzielona
między procesorami. Procesory wykorzystują część pamięci na własne obliczenia,
część przeznaczają na wymianę danych między sobą, czy komunikację i synchronizację.
Każdy procesor posiada również własną pamięć podręczną.

Może się zdarzyć, że procesory będą chciały się ze sobą skomunikować przy
pomocy pewnego fragmentu pamięci. Proces taki pociąga za sobą wymianę linii
pamięci podręcznej między rdzeniami. Dostęp przez dwa procesory do komórki
pamięci $n$, która przechowuje pewną strukturę, może mieć następującą postać:

\begin{enumerate}
\item procesory $A$ i $B$ przechowują we swoich pamięciach podręcznych
bieżącą zawartość $n$,
\item procesor $A$ przygotowuje dane dla $B$ i aktualizuje zawartość $n$,
\item protokół uspójniania pamięci podręcznej informuje $B$, że posiada
nieaktualną wersję linii zawierającej $n$,
\item $B$ żąda odczytu komórki $n$,
\item $A$ synchronizuje zawartość linii przechowującej $n$ z pamiecią
systemową,
\item $B$ pobiera linię przechowującą $n$ do swojej pamięci podręcznej,
\item $B$ posiada aktualną wersję linii przechowującej $n$ i może operować na
jej zawartości.
\end{enumerate}

Proces ten jest dość czasochłonny, ale w przypadku komunikacji
międzyprocesorowej niezbędny.

Może się jednak zdarzyć, że jedna linia pamięci podręcznej przechowuje kilka
struktur, lecz nie służą one do wymiany danych między procesorami -- są
prywatnymi danymi pewnych wątków obliczeń działających na odrębnych procesorach.
Zjawisko takie określa się mianem fałszywego współdzielenia (ang. \textit{false
sharing}). Jest ono bardzo niepożądane, a w przypadku kiedy obejmuje duże
obszary pamięci, prowadzi do poważnego obniżenia wydajności związanego z
masowym przepływem danych między pamięciami podręcznymi procesorów. Sytuację
taką określa się mianem zaśmiecania pamięci podręcznej (ang. \textit{cache
trashing}), które, w dosłownym tego słowa sensie, rujnuje wydajność programu
działającego na architekturze wieloprocesorowej.

\subsection{Synchronizacja między wątkami i procesorami}

\begin{enumerate}
\item \verb+pthread_mutex_t+
\item POSIX semaphores
\item futex
\item spinlocks
\item operacje atomowe
\end{enumerate}


% --=[ Omówienie klasycznych mechanizmów ]=-------------------------------------

\section{Klasyczne menadżery}

Podstawy, z których będę korzystał wymyślając własny algorytm.

\subsection{Strategie wyboru bloku pamięci}

W jaki sposób zarezerwować blok pamięci?

\subsubsection{Best-fit}

Wybór najlepiej pasującego wolnego bloku.

\subsubsection{First-fit}

Wybór pierwszego wolnego bloku, w którym mieści się rezerwowany obszar.

% --=[ Testowanie wydajności ]=-------------------------------------------------

\section{Testowanie wydajności}

\begin{enumerate}
\item test z losowymi parami \textit{(długość życia, wielkość)} o równomiernym rozkładzie,
\item j.w. ale wielowątkowy,
\item test z losowymi parami \textit{(długość życia, wielkość)} o rozkładzie symulujacym rzeczywistość,
\item j.w. ale wielowątkowy,
\item ślady z wykonania programów,
\item wnioski nt. zachowań spotykanych w programach
\end{enumerate}

% --=[ Implementacja ]=---------------------------------------------------------

\section{Implementacja}

\subsection{Założenia}

\subsection{Zgodność ze standardem \texttt{POSIX}}

Programiści, korzystający z menadżera sterty w standardowej bibliotece języka
C, są przyzwyczajeni do tego, że posiadają pewien dobrze znany mechanizm
udostępniający pewną funkcjonalność.

W związku z tym implementacja ogólnego menadżera pamięci powinna być możliwie
jak najbardziej zbliżona pod względem zachowania do tej określonej w
standardzie \texttt{POSIX}.

\subsubsection{Procedura \texttt{malloc}}

Funkcja \texttt{malloc} zwraca wskaźnik do bloku pamięci o rozmiarze
\texttt{size} bajtów lub wartość \texttt{NULL} w przeciwnym wypadku.

\vspace{2ex}
\begin{lstlisting}[caption={Prototyp procedury \texttt{malloc}.}]
void * malloc (size_t size);
\end{lstlisting}

Zwrócony wskaźnik w systemach $32$-bitowych musi być podzielny przez $8$, a w
systemach $64$-bitowych przez $16$. W przypadku błędu zmienna systemowa
\texttt{errno} musi być ustawiona na wartość \texttt{ENOMEM}. Zarezerwowana
pamięć ma nieokreśloną zawartość. Nadpisanie obszaru znajdującego się
bezpośrednio przed jak i za przydzielonym blokiem najprawdopodobniej uszkodzi
prywatne struktury danych allokatora pamięci -- co doprowadzi do nieokreślonego
zachowania menadżera pamięci.

\subsubsection{Procedura \texttt{calloc}}

Funkcja \texttt{calloc} zwraca wskaźnik do wyzerowanego bloku pamięci będącego
w stanie pomieścić tablicę \texttt{count} elementów o rozmiarze
\texttt{eltsize} lub wartość \texttt{NULL} w przeciwnym wypadku.

\vspace{2ex}
\begin{lstlisting}[caption={Prototyp procedury \texttt{calloc}.}]
void * calloc (size_t count, size_t eltsize);
\end{lstlisting}

Procedura ta zachowuję się podobnie jak \texttt{malloc}, poza gwarancją
zainicjalizowania obszaru zerami. Implementacja tego wywołania może, ale nie
musi, korzystać wewnętrznie z wywołania \texttt{malloc}.

\subsubsection{Procedura \texttt{realloc}}

Funkcja \texttt{realloc} zmienia rozmiar bloku wskazywanego przez argument
\texttt{ptr} na \texttt{newsize} bajtów. Jeśli zwrócony adres jest równy
\texttt{ptr} oznacza to, że zarządcy pamięci udało się zmienić rozmiar bloku w
miejscu. W przeciwnym wypadku procedura \texttt{realloc} rezerwuje nowy blok o
rozmiarze \texttt{newsize}, kopiuje do niego zawartość bloku wskazywanego przez
\texttt{ptr} po czym zwalnia stary obszar.

\vspace{2ex}
\begin{lstlisting}[caption={Prototyp procedury \texttt{realloc}.}]
void * realloc (void *ptr, size_t newsize);
\end{lstlisting}

Jeśli \texttt{realloc} zwróci wskaźnik równy \texttt{NULL}, wtedy stary obszar
wskazywany przez \texttt{ptr} zostaje w nienaruszonym stanie, a zmienna
systemowa \texttt{errno} ma wartość \texttt{ENOMEM}.

Funkcja \texttt{realloc} działa jak \texttt{malloc(newsize)}, jeśli argument
\texttt{ptr} jest równy \texttt{NULL}, lub jako \texttt{free(ptr)}, jeśli
argument \texttt{newsize} jest równy $0$.

\subsubsection{Procedura \texttt{posix\_memalign}}

Funkcja \texttt{posix\_memalign} rezerwuje blok pamięci o adresie podzielnym
przez argument \texttt{alignment} (liczba ta musi być potęgą dwójki) oraz przez
\texttt{sizeof(void *)} i o rozmiarze \texttt{size}. Zarezerwowany blok pamięci
umieszczany jest w komórce pamięci wskazywanej przez \texttt{memptr} i funkcja
zwraca $0$. W przypadku błędu funkcja zwraca: \texttt{EINVAL} jeśli
\texttt{alignment} nie spełnia zadanych kryteriów lub \texttt{ENOMEM} jeśli nie
ma wystarczającej ilości pamięci.

\vspace{2ex}
\begin{lstlisting}[caption={Prototyp procedury \texttt{posix\_memalign}, \texttt{memalign} i \texttt{valloc}.},xleftmargin=0cm,xrightmargin=0cm]
int posix_memalign (void **memptr, size_t alignment, size_t size);
void * memalign (size_t boundary, size_t size);
void * valloc (size_t size);
\end{lstlisting}

Funkcja \texttt{memalign} działa analogicznie do \texttt{posix\_memalign} --
przy czym adres jest podzielny tylko przez \texttt{boundary} (będące potęgą
dwójki), a początek zarezerwowanego bloku jest zwracany przez wartość funkcji.
W przypadku błędu adres jest równy \texttt{NULL} i ustawiana jest zmienna
systemowa \texttt{errno}.

Funkcja \texttt{valloc} jest prostą nakładką na \texttt{memalign}, gdzie
wartość argumentu \texttt{boundary} jest równa długości strony, którą można
sprawdzić używając funkcji \texttt{getpagesize()}.

Warto również zauważyć, że w systemach \textit{BSD} pamięć rezerwowana przez te
procedury nie może być zwalniania przez procedurę \texttt{free}.

\subsubsection{Procedura \texttt{free}}

Funkcja \texttt{free} zwalnia blok pamięci, czyniąc przestrzeń przez niego
wykorzystywaną zdatną do ponownego użycia.

\vspace{2ex}
\begin{lstlisting}[caption={Prototyp procedury \texttt{free} i \texttt{cfree}.}]
void free (void *ptr);
void cfree (void *ptr);
\end{lstlisting}

Funkcja \texttt{cfree} jest synonimem \texttt{free} i istnieje wyłącznie ze
względów historycznych -- dla kompatybilności z systemem \textit{SunOS}.

Dostęp do bloku pamięci po jego zwolnieniu mimo, że jest operacją błędną to
często jest możliwy. Istnieją narzędzia wykrywające takie anomalie. Deallokacja
bloku pamięci uszkadza jego zawartość.

Program nie musi zwalniać wszystkiej pamięci przed zakończeniem swego
działania. Automatyczne zarządzanie zasobami odda wykorzystaną przez proces
pamięć na użytek systemu operacyjnego.

Jeśli wskaźnik \texttt{ptr} nie podaje początku bloku pamięci, czyli wartości
zwróconej przez jakieś wywołanie \texttt{malloc}, lub podaje obszar już raz
zwolniony, to zachowanie menadżera pamięci jest nieustalone i może
zakończyć się przerwaniem działania programu.

Jeśli wskaźnik \texttt{ptr} jest równy wartości \texttt{NULL}, to procedura
\texttt{free} nie wykonuje żadnej operacji.

\subsubsection{Pozostałe procedury menadżera zgodnego z \texttt{POSIX}}

\vspace{2ex}
\begin{lstlisting}[caption={Prototypy pozostałych procedur i zmiennych.}]
int mallopt (int param, int value);
int mcheck (void (*abortfn)(void));
struct mallinfo mallinfo (void);

\end{lstlisting}

\subsection{Menadżer stron -- \texttt{PAGEMAN}}

\subsection{Zarządca dużych obszarów -- \texttt{MMAPMAN-AO}}

Obszary o rozmiarze $\ge 32KiB$.

\subsection{Zarządca małych obszarów -- \texttt{REAPS}}

Obszary o rozmarze $< 24B$.

\begin{figure}
\centering
\includegraphics[width=0.80\textwidth]{reaps}
\caption{Graficzna reprezentacja struktury danych \texttt{reaps}}
\end{figure}

\subsection{Zarządca pozostałych obszarów -- \texttt{BLKMAN-AO}}

Obszary o rozmiarze $\ge 24B$ i $< 32KiB$.

\begin{figure}
\centering
\includegraphics[width=0.90\textwidth]{blkman}
\caption{Graficzna reprezentacja struktury danych \texttt{blkman}}
\end{figure}

% --=[ Wnioski ]=---------------------------------------------------------------

\section{Wnioski i kierunek badań}

Śmieci i inne pomysły, o których lepiej nie zapomnieć, a trzeba gdzieś umieścić:
\begin{itemize}
\item istotne dla wydajności dostępów do pamięci jest umieszczanie danych w
adresach o naturalnych wartościach tj. $32$-bitowe słowo powinno być pod
adresem podzielnym przez $4$,
\item wywołania systemowe są operacjami kosztownymi i nie można ich robić zbyt często,
\end{itemize}

\end{document}
